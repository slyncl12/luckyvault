import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';
import { SuiClient } from '@mysten/sui/client';
import { Transaction } from '@mysten/sui/transactions';
import { naviService } from './NaviService';

interface RebalancerConfig {
  minBalanceUsdc: number;
  targetBalanceUsdc: number;
  maxBalanceUsdc: number;
  checkIntervalMs: number;
}

export class PoolRebalancer {
  private suiClient: SuiClient;
  private keypair: Ed25519Keypair;
  private poolObjectId: string;
  private config: RebalancerConfig;
  private intervalId?: NodeJS.Timeout;
  private isRunning = false;

  constructor(
    suiClient: SuiClient,
    keypair: Ed25519Keypair,
    poolObjectId: string,
    config: RebalancerConfig
  ) {
    this.suiClient = suiClient;
    this.keypair = keypair;
    this.poolObjectId = poolObjectId;
    this.config = config;
  }

  async start(): Promise<void> {
    if (this.isRunning) {
      console.log('‚ö†Ô∏è  Rebalancer is already running');
      return;
    }

    console.log('üöÄ Starting Pool Rebalancer...');
    console.log(`   Min Balance: $${this.config.minBalanceUsdc.toFixed(2)}`);
    console.log(`   Target Balance: $${this.config.targetBalanceUsdc.toFixed(2)}`);
    console.log(`   Max Balance: $${this.config.maxBalanceUsdc.toFixed(2)}`);
    console.log(`   Check Interval: ${this.config.checkIntervalMs / 1000}s`);

    // Initialize NAVI
    await naviService.initialize();

    this.isRunning = true;

    // Run initial check
    await this.checkAndRebalance();

    // Set up interval
    this.intervalId = setInterval(async () => {
      await this.checkAndRebalance();
    }, this.config.checkIntervalMs);

    console.log('‚úÖ Pool Rebalancer started (using NAVI Protocol)\n');
  }

  stop(): void {
    if (!this.isRunning) {
      return;
    }

    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = undefined;
    }

    this.isRunning = false;
    console.log('üõë Pool Rebalancer stopped');
  }

  private async checkAndRebalance(): Promise<void> {
    try {
      console.log('‚è∞ Running rebalance check...');

      // Get pool status
      const poolBalance = await this.getPoolBalance();
      const naviBalance = await this.getNaviBalance();
      const totalBalance = poolBalance + naviBalance;
      const yieldEarned = 0; // TODO: Calculate yield

      console.log('üìä Pool Status:');
      console.log(`   Total Balance: $${totalBalance.toFixed(2)}`);
      console.log(`   In Pool: $${poolBalance.toFixed(2)}`);
      console.log(`   In NAVI: $${naviBalance.toFixed(2)}`);
      console.log(`   Yield Earned: $${yieldEarned.toFixed(2)}`);

      // Check if rebalancing is needed
      if (poolBalance > this.config.maxBalanceUsdc) {
        // Pool has too much - deposit to NAVI
        const excessAmount = poolBalance - this.config.targetBalanceUsdc;
        console.log('üîÑ Rebalancing needed!');
        console.log(`   Action: DEPOSIT`);
        console.log(`   Amount: $${excessAmount.toFixed(2)}`);

        await this.depositExcessToNavi(excessAmount);
      } else if (poolBalance < this.config.minBalanceUsdc && naviBalance > 0) {
        // Pool has too little - withdraw from NAVI
        const neededAmount = this.config.targetBalanceUsdc - poolBalance;
        const withdrawAmount = Math.min(neededAmount, naviBalance);
        console.log('üîÑ Rebalancing needed!');
        console.log(`   Action: WITHDRAW`);
        console.log(`   Amount: $${withdrawAmount.toFixed(2)}`);

        await this.withdrawFromNaviToPool(withdrawAmount);
      } else {
        console.log('‚úÖ Pool is balanced, no action needed');
      }

      console.log();
    } catch (error) {
      console.error('‚ùå Error during rebalance check:', error);
    }
  }

  private async getPoolBalance(): Promise<number> {
    try {
      const poolObject = await this.suiClient.getObject({
        id: this.poolObjectId,
        options: { showContent: true },
      });

      if (!poolObject.data?.content || poolObject.data.content.dataType !== 'moveObject') {
        throw new Error('Invalid pool object');
      }

      const fields = poolObject.data.content.fields as any;
      const balance = Number(fields.balance || 0);
      return balance / 1_000_000; // Convert from base units to USDC
    } catch (error) {
      console.error('Error getting pool balance:', error);
      return 0;
    }
  }

  private async getNaviBalance(): Promise<number> {
    try {
      const position = await naviService.getUserPosition(this.keypair.toSuiAddress());
      if (!position) return 0;
      return parseFloat(position.currentValue) / 1_000_000;
    } catch (error) {
      console.error('Error getting NAVI balance:', error);
      return 0;
    }
  }

  private async depositExcessToNavi(amount: number): Promise<void> {
    try {
      console.log(`üí∞ Depositing $${amount.toFixed(2)} to NAVI...`);

      // Step 1: Withdraw from pool using admin function
      const withdrawResult = await this.withdrawFromPool(amount);

      if (!withdrawResult.success || !withdrawResult.coinId) {
        throw new Error('Failed to withdraw from pool');
      }

      console.log('‚úÖ Withdrew $' + amount.toFixed(2) + ' from pool');
      console.log('   Transaction:', withdrawResult.digest);
      console.log('üìç USDC Coin ID:', withdrawResult.coinId);

      // Wait for transaction to finalize on-chain
      console.log('‚è≥ Waiting 5 seconds for transaction to finalize...');
      await new Promise(resolve => setTimeout(resolve, 5000));

      // Step 2: Deposit directly to NAVI
      console.log('üì§ Depositing to NAVI...');

      try {
        await this.depositSpecificCoinToNavi(
          withdrawResult.coinId,
          amount
        );

        console.log('‚úÖ Successfully deposited to NAVI!');

        // Get current APY
        try {
          const apy = await naviService.getUSDCSupplyAPY();
          console.log(`   üí∞ Now earning ${apy.toFixed(2)}% APY on NAVI!`);
        } catch (e) {
          console.log('   üí∞ Now earning yield on NAVI!');
        }

        // TRACKER UPDATE DISABLED - No longer needed since we query NAVI directly
        // (Old code tracked deposits but had stale data from tests)
        console.log('‚úÖ Successfully deposited to NAVI!');
        console.log(`   üí∞ Now earning ${this.lastKnownAPY.toFixed(2)}% APY on NAVI!');

      } catch (error) {
        console.error('‚ùå NAVI deposit failed:', error);
        console.log('üí∞ Attempting to return funds to pool...');

        // Return the coin to the pool
        try {
          const returnTx = new Transaction();
          returnTx.moveCall({
            target: `${process.env.VITE_POOL_PACKAGE_ID}::lottery_personal::admin_deposit_from_suilend`,
            typeArguments: [process.env.VITE_USDC_TYPE!],
            arguments: [
              returnTx.object(process.env.VITE_ADMIN_CAP_ID!),
              returnTx.object(this.poolObjectId),
              returnTx.object(withdrawResult.coinId),
              returnTx.object(process.env.VITE_CLOCK_ID!),
            ],
          });

          await this.suiClient.signAndExecuteTransaction({
            transaction: returnTx,
            signer: this.keypair,
            options: { showEffects: true },
          });

          console.log('‚úÖ Funds returned to pool');
        } catch (returnError) {
          console.error('‚ùå Failed to return funds to pool:', returnError);
          console.error('‚ö†Ô∏è  Manual intervention required - coin ID:', withdrawResult.coinId);
        }

        throw error;
      }

    } catch (error) {
      console.error('‚ùå Error depositing to NAVI:', error);
      throw error;
    }
  }

  private async withdrawFromPool(amount: number): Promise<{
    success: boolean;
    digest?: string;
    coinId?: string;
  }> {
    try {
      const amountInBaseUnits = Math.floor(amount * 1_000_000);

      const tx = new Transaction();

      // Call admin_withdraw_for_suilend (function name unchanged for compatibility)
      tx.moveCall({
        target: `${process.env.VITE_POOL_PACKAGE_ID}::lottery_personal::admin_withdraw_for_suilend`,
        typeArguments: [process.env.VITE_USDC_TYPE!],
        arguments: [
          tx.object(process.env.VITE_ADMIN_CAP_ID!),
          tx.object(this.poolObjectId),
          tx.pure.u64(amountInBaseUnits),
          tx.object(process.env.VITE_CLOCK_ID!),
        ],
      });

      const result = await this.suiClient.signAndExecuteTransaction({
        transaction: tx,
        signer: this.keypair,
        options: {
          showEffects: true,
          showObjectChanges: true,
        },
      });

      // Extract the created USDC coin ID
      const createdObjects = result.objectChanges?.filter(
        (change: any) => change.type === 'created'
      );

      const usdcCoin = createdObjects?.find((obj: any) =>
        obj.objectType?.includes('usdc::USDC') && !obj.objectType?.includes('CToken')
      );

      if (!usdcCoin) {
        throw new Error('Could not find created USDC coin');
      }

      return {
        success: true,
        digest: result.digest,
        coinId: usdcCoin.objectId,
      };
    } catch (error) {
      console.error('Error withdrawing from pool:', error);
      return { success: false };
    }
  }

  private async depositSpecificCoinToNavi(
    usdcCoinId: string,
    amount: number
  ): Promise<void> {
    try {
      // CRITICAL SAFETY CHECK: Verify this coin came from our pool withdrawal
      const coinInfo = await this.suiClient.getObject({
        id: usdcCoinId,
        options: {
          showContent: true,
          showType: true,
          showPreviousTransaction: true
        },
      });

      if (!coinInfo.data) {
        throw new Error(`Coin ${usdcCoinId} not found`);
      }

      // Verify it's USDC
      if (!coinInfo.data.type?.includes('usdc::USDC')) {
        throw new Error(`Coin ${usdcCoinId} is not USDC`);
      }

      console.log(`   ‚úÖ Verified coin ${usdcCoinId} is USDC from pool withdrawal`);

      // Deposit to NAVI using our service
      await naviService.depositToNavi(
        this.keypair,
        usdcCoinId,
        Math.floor(amount * 1_000_000)
      );
    } catch (error) {
      console.error('Error in depositSpecificCoinToNavi:', error);
      throw error;
    }
  }

  private async withdrawFromNaviToPool(amount: number): Promise<void> {
    console.log(`üí∏ Withdrawing $${amount.toFixed(2)} from NAVI to pool...`);

    try {
      // Get current NAVI position
      const position = await naviService.getUserPosition(this.keypair.toSuiAddress());

      if (!position || parseFloat(position.currentValue) < amount * 1_000_000) {
        throw new Error('Insufficient balance in NAVI');
      }

      // Withdraw from NAVI
      console.log('üì§ Creating NAVI withdrawal transaction...');
      const tx = await naviService.withdrawFromNavi(
        this.keypair.toSuiAddress(),
        amount
      );

      // Execute transaction
      const result = await this.suiClient.signAndExecuteTransaction({
        transaction: tx,
        signer: this.keypair,
        options: {
          showEffects: true,
          showObjectChanges: true,
        },
      });

      console.log('‚úÖ Withdrew from NAVI');
      console.log('   Transaction:', result.digest);

      // The withdrawn USDC is now in admin wallet
      // Wait for indexing
      await new Promise(resolve => setTimeout(resolve, 5000));

      // Find the withdrawn USDC coin
      const coins = await this.suiClient.getCoins({
        owner: this.keypair.toSuiAddress(),
        coinType: process.env.VITE_USDC_TYPE!
      });

      // Find a coin with balance >= amount (recently created)
      const withdrawnCoin = coins.data.find(c => parseInt(c.balance) >= amount * 1_000_000);

      if (!withdrawnCoin) {
        throw new Error('Could not find withdrawn USDC coin');
      }

      console.log('üí∞ Depositing back to pool...');

      // Deposit back to pool using admin_deposit_from_suilend (function name unchanged)
      const depositTx = new Transaction();
      depositTx.moveCall({
        target: `${process.env.VITE_POOL_PACKAGE_ID}::lottery_personal::admin_deposit_from_suilend`,
        typeArguments: [process.env.VITE_USDC_TYPE!],
        arguments: [
          depositTx.object(process.env.VITE_ADMIN_CAP_ID!),
          depositTx.object(this.poolObjectId),
          depositTx.object(withdrawnCoin.coinObjectId),
          depositTx.object(process.env.VITE_CLOCK_ID!),
        ],
      });

      await this.suiClient.signAndExecuteTransaction({
        transaction: depositTx,
        signer: this.keypair,
        options: { showEffects: true },
      });

      console.log('‚úÖ Deposited $' + amount.toFixed(2) + ' back to pool');

      // Update tracker
      console.log('üìù Updating withdrawal tracker...');
      try {
        const trackerObj = await this.suiClient.getObject({
          id: process.env.VITE_SUILEND_TRACKER_ID!,
          options: { showContent: true }
        });

        const trackerFields = (trackerObj.data?.content as any)?.fields;
        const currentDeposited = parseInt(trackerFields?.deposited_to_suilend || '0');

        // TRACKER UPDATE DISABLED - No longer needed since we query NAVI directly
        console.log('‚úÖ Withdrawn from NAVI: $' + amount.toFixed(2));

      } catch (trackError) {
        console.error('‚ùå Failed withdrawal:', trackError);
      }

    } catch (error) {
      console.error('Error withdrawing from NAVI:', error);
      throw error;
    }
  }

  /**
   * Harvest accumulated yield from NAVI for prize distribution
   * This should be called when there's a winner
   */
  private async harvestYieldForPrize(): Promise<number> {
    try {
      // Get current NAVI position value
      const position = await naviService.getUserPosition(this.keypair.toSuiAddress());
      if (!position) return 0;

      const currentValue = parseFloat(position.currentValue) / 1_000_000;

      // Get tracked deposit amount
      const trackerObj = await this.suiClient.getObject({
        id: process.env.VITE_SUILEND_TRACKER_ID!,
        options: { showContent: true }
      });
      const trackerFields = (trackerObj.data?.content as any)?.fields;
      const trackedDeposit = parseInt(trackerFields?.deposited_to_suilend || '0') / 1_000_000;

      // Calculate available yield
      const yieldAvailable = Math.max(0, currentValue - trackedDeposit);

      console.log('üí∞ Yield Available for Prizes:');
      console.log('   NAVI Value: $' + currentValue.toFixed(2));
      console.log('   Tracked Principal: $' + trackedDeposit.toFixed(2));
      console.log('   Harvestable Yield: $' + yieldAvailable.toFixed(2));

      return yieldAvailable;

    } catch (error) {
      console.error('Error calculating yield:', error);
      return 0;
    }
  }
}

// Export singleton rebalancer
export let poolRebalancer: PoolRebalancer | null = null;

export function createPoolRebalancer(
  suiClient: SuiClient,
  keypair: Ed25519Keypair,
  poolObjectId: string,
  config: RebalancerConfig
): PoolRebalancer {
  poolRebalancer = new PoolRebalancer(suiClient, keypair, poolObjectId, config);
  return poolRebalancer;
}
